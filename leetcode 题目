##### leetcode上的题目和自己给的一些解法。 先放上来之后再优化。


Two sum:

class Solution(object):
    def twoSum(self, nums, target):
        for i in nums:
            ano=target-i
            if ano in nums:
                if ano == i:
                    if nums.count(ano)>1:
                        numss=nums[:]
                        numss.remove(i)
                        return[nums.index(i),numss.index(ano)+1]
                    else:
                        continue
                else:
                    return [nums.index(i),nums.index(ano)]
            else:
                continue


Add two numbers:

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def addTwoNumbers(self, l1, l2):
        
        TrueResult=ListNode(0)
        result=TrueResult

        while l1 or l2 :
            if l1 and l2:
                if result.next:
                    a=l1.val+l2.val+result.next.val
                    if a < 10:
                        print('case1')
                        result.next=ListNode(a)
                    else:
                        print('case2')
                        result.next=ListNode(a%10)
                        result.next.next=ListNode(1)
                else:
                    a=l1.val+l2.val
                    if a < 10:
                        print('case3')
                        result.next=ListNode(a)
                    else:
                        print('case4')
                        result.next=ListNode(a%10)
                        result.next.next=ListNode(1)
                l1=l1.next
                l2=l2.next
            elif not l1 and l2:
                if result.next:
                    a=l2.val+result.next.val
                    if a < 10:
                        print('case5')
                        result.next=ListNode(a)
                    else:
                        print('case6')
                        result.next=ListNode(a%10)
                        result.next.next=ListNode(1)
                else:
                    print('case7')
                    a=l2.val
                    result.next=ListNode(a)
                    
                l2=l2.next
            elif not l2 and l1:
                if result.next:
                    a=l1.val+result.next.val
                    if a < 10:
                        print('case8')
                        result.next=ListNode(a)
                    else:
                        print('case9')
                        result.next=ListNode(a%10)
                        result.next.next=ListNode(1)
                else:
                    print('case10')
                    result.next=ListNode(l1.val)
                l1=l1.next
            result=result.next
            
        return TrueResult.next
                
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        

Container With Most Water 

class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        start = 0
        end=len(height)-1
        max_c=min(height[start],height[end])*(end-start)
        
        while end>start:
            if height[start]>height[end]:
                end-=1
                max_c=max(max_c,min(height[start],height[end])*(end-start))
            else:
                start+=1
                max_c=max(max_c,min(height[start],height[end])*(end-start))
        return max_c



3 Sum

class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums=sorted(nums)
        result=[]
        for i in range(len(nums)):
            if nums[i]>0:
                break
            if i>0 and nums[i]==nums[i-1]:
                continue
            l=i+1
            r=len(nums)-1
            while(l<r):
                add=nums[i]+nums[l]+nums[r]
                if add>0:
                    r-=1
                elif add<0:
                    l+=1
                else:
                    result.append([nums[i],nums[l],nums[r]])
                    while l<r and nums[l]==nums[l+1]:
                        l+=1
                    while l<r and nums[r]==nums[r-1]:
                        r-=1
                    l+=1
                    r-=1
        return result
        

Letter Combinations of a Phone Number

class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        global dic
        global wow
        wow=[]
        dic={
            '2':['a','b','c'],
            '3':['d','e','f'],
            '4':['g','h','i'],
            '5':['j','k','l'],
            '6':['m','n','o'],
            '7':['p','q','r','s'],
            '8':['t','u','v'],
            '9':['w','x','y','z']}
        if len(digits) ==0:
            return ''
        else:
            #digits=list(map(int,list(digits)))

            self.count('',digits)
            return wow
        
        
    
    def count(self,count,digits):
        
        if len(count)>=len(digits):
            wow.append(count)
            return
        else:
            for i in dic[digits[len(count)]]: # the value count can represent the length information and the letter series here
                 self.count(count+i,digits)



Remove Nth Node From End of List

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: ListNode
        :type n: int
        :rtype: ListNode
        """
        if n == 0:
            return head
        else:
            lengt=0
            start = head
            while(start is not None):
                start=start.next
                lengt+=1
            
            start = head
            for i in range(lengt):
                if lengt==n:
                    head=head.next
                    break
                elif i == lengt-n-1:
                    start.next=start.next.next
                    break
                else:
                    start=start.next
            return head


Valid Parentheses

class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        dic = {'{':'}','(':')','[':']'}
        query=[]
        if len(s)%2!=0:
            return False
        for i in range(len(s)):
            if len(query)==0:
                if s[i] not in ['{','[','(']:
                    return False
                else:
                    query.append(s[i])
            else:
                if s[i]==dic[query[-1]]:
                    query.pop(-1)
                elif s[i] not in ['{','[','(']:
                    return False
                else:
                    query.append(s[i])
        if len(query)!=0:
            return False
        return True
       

Merge Two Sorted Lists

# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """
        origin=ListNode(1)
        start1=l1
        start2=l2
        start3=origin
        while (start1 is not None or start2 is not None):
            if(start1 is not None and start2 is not None):
                if start1.val<start2.val:
                    start3.next=ListNode(start1.val)
                    start1=start1.next
                    start3=start3.next
                elif start1.val>start2.val:
                    start3.next=ListNode(start2.val)
                    start2=start2.next
                    start3=start3.next
                elif start1.val==start2.val:
                    start3.next=ListNode(start1.val)
                    start3.next.next=ListNode(start2.val)
                    start1,start2=start1.next,start2.next
                    start3=start3.next.next
            elif not start1:
                start3.next=start2
                break
            elif not start2:
                start3.next = start1
                break
        return origin.next
            
 
Generate Parentheses

class Solution(object):
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        if n <1:
            return []
        self.create(n)
        return list(set(result)) # remove some repulicated stuff
    def create(self,n):
        if n==1:
            global result
            result=['()']
            #print(result)
            return
        else:
            xx=[]
            self.create(n-1)
            for i in result:
                for j in range(len(i)):
                    if i[j] ==')':
                        xx.append(i[:j]+'()'+i[j:])
            xx.append(result[-1]+'()')
            result = xx




       
